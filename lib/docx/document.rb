require 'docx/containers'
require 'docx/elements'
require 'docx/elements/image'
require 'docx/errors'
require 'docx/helpers'
require 'nokogiri'
require 'zip'
require 'securerandom'
require 'fileutils'

module Docx
  # The Document class wraps around a docx file and provides methods to
  # interface with it.
  #
  #   # get a Docx::Document for a docx file in the local directory
  #   doc = Docx::Document.open("test.docx")
  #
  #   # get the text from the document
  #   puts doc.text
  #
  #   # do the same thing in a block
  #   Docx::Document.open("test.docx") do |d|
  #     puts d.text
  #   end
  class Document
    include Docx::SimpleInspect

    attr_reader :xml, :doc, :zip, :styles

    def initialize(path_or_io, options = {})
      @replace = {}

      # if path-or_io is string && does not contain a null byte
      if (path_or_io.instance_of?(String) && !/\u0000/.match?(path_or_io))
        @zip = Zip::File.open(path_or_io)
      else
        @zip = Zip::File.open_buffer(path_or_io)
      end

      document = @zip.glob('word/document*.xml').first
      raise Errno::ENOENT if document.nil?

      @document_xml = document.get_input_stream.read
      @doc = Nokogiri::XML(@document_xml)
      load_styles
      yield(self) if block_given?
    ensure
      @zip.close unless @zip.nil?
    end

    # This stores the current global document properties, for now
    def document_properties
      {
        font_size: font_size,
        hyperlinks: hyperlinks
      }
    end

    # With no associated block, Docx::Document.open is a synonym for Docx::Document.new. If the optional code block is given, it will be passed the opened +docx+ file as an argument and the Docx::Document oject will automatically be closed when the block terminates. The values of the block will be returned from Docx::Document.open.
    # call-seq:
    #   open(filepath) => file
    #   open(filepath) {|file| block } => obj
    def self.open(path, &block)
      new(path, &block)
    end

    def paragraphs
      @doc.xpath('//w:document//w:body/w:p').map { |p_node| parse_paragraph_from p_node }
    end

    def bookmarks
      bkmrks_hsh = {}
      bkmrks_ary = @doc.xpath('//w:bookmarkStart').map { |b_node| parse_bookmark_from b_node }
      # auto-generated by office 2010
      bkmrks_ary.reject! { |b| b.name == '_GoBack' }
      bkmrks_ary.each { |b| bkmrks_hsh[b.name] = b }
      bkmrks_hsh
    end

    def to_xml
      Nokogiri::XML(@document_xml)
    end

    def tables
      @doc.xpath('//w:document//w:body//w:tbl').map { |t_node| parse_table_from t_node }
    end

    # Some documents have this set, others don't.
    # Values are returned as half-points, so to get points, that's why it's divided by 2.
    def font_size
      size_value = @styles&.at_xpath('//w:docDefaults//w:rPrDefault//w:rPr//w:sz/@w:val')&.value

      return nil unless size_value

      size_value.to_i / 2
    end

    # Hyperlink targets are extracted from the document.xml.rels file
    def hyperlinks
      hyperlink_relationships.each_with_object({}) do |rel, hash|
        hash[rel.attributes['Id'].value] = rel.attributes['Target'].value
      end
    end

    def hyperlink_relationships
      @rels.xpath("//xmlns:Relationship[contains(@Type,'hyperlink')]")
    end

    ##
    # *Deprecated*
    #
    # Iterates over paragraphs within document
    # call-seq:
    #   each_paragraph => Enumerator
    def each_paragraph
      paragraphs.each { |p| yield(p) }
    end

    # call-seq:
    #   to_s -> string
    def to_s
      paragraphs.map(&:to_s).join("\n")
    end

    # Output entire document as a String HTML fragment
    def to_html
      paragraphs.map(&:to_html).join("\n")
    end

    # Save document to provided path
    # call-seq:
    #   save(filepath) => void
    def save(path)
      update
      Zip::OutputStream.open(path) do |out|
        # First, write all existing entries (potentially replaced)
        zip.each do |entry|
          next unless entry.file?

          out.put_next_entry(entry.name)
          value = @replace[entry.name] || zip.read(entry.name)

          out.write(value)
        end
        
        # Then, write any new entries that were added via @replace
        # but don't exist in the original ZIP
        @replace.each do |entry_name, content|
          next if zip.find_entry(entry_name) # Skip if already written above
          
          out.put_next_entry(entry_name)
          out.write(content)
        end

      end
      zip.close
    end

    # Output entire document as a StringIO object
    def stream
      update
      stream = Zip::OutputStream.write_buffer do |out|
        # First, write all existing entries (potentially replaced)
        zip.each do |entry|
          next unless entry.file?

          out.put_next_entry(entry.name)

          if @replace[entry.name]
            out.write(@replace[entry.name])
          else
            out.write(zip.read(entry.name))
          end
        end
        
        # Then, write any new entries that were added via @replace
        # but don't exist in the original ZIP
        @replace.each do |entry_name, content|
          next if zip.find_entry(entry_name) # Skip if already written above
          
          out.put_next_entry(entry_name)
          out.write(content)
        end
      end

      stream.rewind
      stream
    end

    alias text to_s

    # Universal field replacement that works regardless of text run splitting
    # @param replacements [Hash] field_name => replacement_value pairs
    # @param start_delimiter [String] opening delimiter (default: '_')
    # @param end_delimiter [String] closing delimiter (default: '_')
    # @example
    #   doc.replace_fields({'name' => 'John Doe', 'date' => '2024-01-01'})
    #   doc.replace_fields({'name' => 'John'}, '{{', '}}') # for {{name}} pattern
    def replace_fields(replacements, start_delimiter = '_', end_delimiter = '_')
      # Process paragraphs
      paragraphs.each do |paragraph|
        paragraph.replace_fields(replacements, start_delimiter, end_delimiter)
      end
      
      # Process tables
      tables.each do |table|
        table.rows.each do |row|
          row.cells.each do |cell|
            cell.paragraphs.each do |paragraph|
              paragraph.replace_fields(replacements, start_delimiter, end_delimiter)
            end
          end
        end
      end
    end

    # Add a new paragraph with optional content and formatting
    # @param content [String] initial text content (optional)
    # @param options [Hash] formatting options
    # @return [Paragraph] the newly created paragraph
    def add_paragraph(content = nil, options = {})
      body_node = @doc.at_xpath('//w:body')
      
      # Create paragraph node
      p_node = Nokogiri::XML::Node.new('w:p', @doc)
      body_node.add_child(p_node)
      
      # Create paragraph object
      paragraph = parse_paragraph_from(p_node)
      
      # Add content if provided
      if content
        if options.any?
          paragraph.add_text(content, options)
        else
          paragraph.text = content
        end
      end
      
      paragraph
    end

    # Add a paragraph with bold text
    def add_bold_paragraph(content)
      add_paragraph(content, bold: true)
    end

    # Add a paragraph with italic text  
    def add_italic_paragraph(content)
      add_paragraph(content, italic: true)
    end

    # Add an image to the document
    # @param image_path [String] path to the image file
    # @param options [Hash] image options
    # @option options [Integer] :width image width in pixels (required)
    # @option options [Integer] :height image height in pixels (required)
    # @option options [Integer] :ppi pixels per inch (default: 72)
    # @return [Elements::Containers::Paragraph] paragraph containing the image
    def add_image(image_path, options = {})
      raise ArgumentError, "Image file not found: #{image_path}" unless File.exist?(image_path)
      raise ArgumentError, "Width is required" unless options[:width]
      raise ArgumentError, "Height is required" unless options[:height]
      
      # Generate unique IDs - make sure relationship ID is actually unique
      image_id = "image#{SecureRandom.hex(8)}"
      rel_id = generate_unique_relationship_id
      
      # Get file extension
      ext = File.extname(image_path).downcase.delete('.')
      media_path = "word/media/#{image_id}.#{ext}"
      
      # Read image data
      image_data = File.binread(image_path)
      
      # Add image to the zip archive
      replace_entry(media_path, image_data)
      
      # Add relationship to document.xml.rels
      add_image_relationship(rel_id, "media/#{image_id}.#{ext}")
      
      # Add content type for the image
      add_image_content_type(ext)
      
      # Create paragraph with image
      paragraph = add_paragraph
      
      # Create run node
      run_node = Nokogiri::XML::Node.new('w:r', @doc)
      paragraph.node.add_child(run_node)
      
      # Create image element
      image = Elements::Image.new(run_node, {
        path: image_path,
        width: options[:width],
        height: options[:height],
        ppi: options[:ppi] || 72,
        relationship_id: rel_id
      })
      
      # Add image XML to run
      run_node.add_child(image.to_xml)
      
      paragraph
    end

    private

    def generate_unique_relationship_id
      # Get existing relationship IDs to avoid conflicts
      load_rels if @rels.nil?
      existing_ids = @rels.xpath('//xmlns:Relationship/@Id').map(&:value)
      
      # Find next available rId number
      max_id = existing_ids.map { |id| id.match(/rId(\d+)/)&.[](1)&.to_i }.compact.max || 0
      "rId#{max_id + 1}"
    end
    
    def add_image_relationship(rel_id, target)
      # Ensure rels document exists
      load_rels if @rels.nil?
      
      # Check if relationship already exists
      existing = @rels.at_xpath("//xmlns:Relationship[@Id='#{rel_id}']")
      return if existing
      
      # Create new relationship
      relationships = @rels.at_xpath('//xmlns:Relationships')
      rel = Nokogiri::XML::Node.new('Relationship', @rels)
      rel['Id'] = rel_id
      rel['Type'] = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image'
      rel['Target'] = target
      relationships.add_child(rel)
      
      # Save updated rels
      replace_entry('word/_rels/document.xml.rels', @rels.to_xml)
    end
    
    def add_image_content_type(ext)
      # Load content types if not already loaded
      unless @content_types
        content_types_entry = @zip.find_entry('[Content_Types].xml')
        if content_types_entry
          @content_types_xml = content_types_entry.get_input_stream.read
          @content_types = Nokogiri::XML(@content_types_xml)
        end
      end
      
      return unless @content_types
      
      # Map file extensions to MIME types
      content_type_map = {
        'png' => 'image/png',
        'jpg' => 'image/jpeg',
        'jpeg' => 'image/jpeg',
        'gif' => 'image/gif',
        'bmp' => 'image/bmp'
      }
      
      mime_type = content_type_map[ext]
      return unless mime_type
      
      # Check if content type already exists
      types = @content_types.at_xpath('//xmlns:Types')
      existing = types.at_xpath("xmlns:Default[@Extension='#{ext}']")
      return if existing
      
      # Add content type
      default_element = Nokogiri::XML::Node.new('Default', @content_types)
      default_element['Extension'] = ext
      default_element['ContentType'] = mime_type
      types.add_child(default_element)
      
      # Save updated content types
      replace_entry('[Content_Types].xml', @content_types.to_xml)
    end

    def replace_entry(entry_path, file_contents)
      @replace[entry_path] = file_contents
    end

    def default_paragraph_style
      @styles.at_xpath("w:styles/w:style[@w:type='paragraph' and @w:default='1']/w:name/@w:val").value
    end

    def style_name_of(style_id)
      styles_configuration.style_of(style_id).name
    end

    def styles_configuration
      @styles_configuration ||= Elements::Containers::StylesConfiguration.new(@styles.dup)
    end

    def load_styles
      @styles_xml = @zip.read('word/styles.xml')
      @styles = Nokogiri::XML(@styles_xml)
      load_rels
    rescue Errno::ENOENT => e
      warn e.message
      nil
    end

    def load_rels
      rels_entry = @zip.glob('word/_rels/document*.xml.rels').first
      raise Errno::ENOENT unless rels_entry

      @rels_xml = rels_entry.get_input_stream.read
      @rels = Nokogiri::XML(@rels_xml)
    end

    #--
    # TODO: Flesh this out to be compatible with other files
    # TODO: Method to set flag on files that have been edited, probably by inserting something at the
    # end of methods that make edits?
    #++
    def update
      replace_entry 'word/document.xml', doc.serialize(save_with: 0)
      replace_entry 'word/styles.xml', styles_configuration.serialize(save_with: 0)
    end

    # generate Elements::Containers::Paragraph from paragraph XML node
    def parse_paragraph_from(p_node)
      Elements::Containers::Paragraph.new(p_node, document_properties, self)
    end

    # generate Elements::Bookmark from bookmark XML node
    def parse_bookmark_from(b_node)
      Elements::Bookmark.new(b_node)
    end

    def parse_table_from(t_node)
      Elements::Containers::Table.new(t_node)
    end
  end
end
